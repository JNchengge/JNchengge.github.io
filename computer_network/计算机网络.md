# 
# 链路层

## 基础术语：
 - 结点(nodes)
 - 链路(links)
 - 帧`(frame)`：链路层中的数据包，包含了网络层中的数据报`(datagram)`
 - 链路层负责从一个结点，通过一条链路，将数据传到物理相邻的另一个结点

## 数据链路层是非常重要的一层：
- 在网络中，无论是主机还是路由，都必须实现这一层，比如
 - 主机的五层结构：应用层、运输层、网络层、<font color=#FF0033>链路层</font>、物理层
 - 路由的三层结构：网络层、<font color=#FF0033>链路层</font>、物理层
 - 都实现了<font color=#FF0033>链路层</font>这一结构
- 在局域网中，无论是主机还是交换机，也都必须实现链路层
 - 主机的五层结构：应用层、运输层、网络层、<font color=#FF0033>链路层</font>、物理层
 - 交换机的两层结构：<font color=#FF0033>链路层</font>、物理层
 - 也都实现了<font color=#FF0033>链路层</font>这一结构

## 数据链路层的作用
- 假设有两台主机H1、H2在通信，两台主机间的数据可能经过多种不同的网络，比如：广域网、局域网、电话网
- 先看主机的数据流动，是从应用层开始，经过完整的五层协议，最后在信道上传输
- 数据到达路由器的时候，也得自底向上、自顶向下地传输
- 所以，当我们研究数据链路层的问题时，可以忽略其他的层，直接看数据在链路层上的流动
- **在只看链路层进行分析的时候，一定要注意，不同的网络，不同的结点之间，使用的有可能是不同的协议**

## 数据链路层传送的是帧
- 帧`(frame)`：链路层中的数据包，包含了网络层中的数据报`(datagram)`

## 链路层的实现
1. 实现为适配器的形式(adapter或者网卡NIC)或者在芯片上实现，往往同时包含链路层和物理层的实现
2. 适配器/NIC再接入到主机的系统主线

## 数据链路层的三个基本问题：

### 封装成帧：
- 在一段数据的前后加上首部和尾部，就构成了一个帧
- 接收端收到物理层上交的比特流后，根据首部和尾部的标记，识别帧的开始和结束
- 一个帧是链路层的数据传送单元
- 一个帧的帧长等于数据的长度加上首部和尾部的长度
- 首部和尾部的重要作用是<font color=#FF0033>帧定界（确定帧的界限）</font>
- 每一种链路层协议都规定了所能传送的帧的数据部分长度上限——最大传送单元`MTU(Maximum Transfer Unit)`

### 透明传输*：

### 差错检测：
- 在传输过程中，可能因为信号放大、噪声等问题，导致比特出错
- <font color=#FF0033>误码率</font>：传输错误的比特占所传输比特总数的比率

#### 奇偶校验：
- 若数据中有奇数个1，则奇偶校验位为1

##### 单个位奇偶校验：
- 比如：`0111000110101011|0`是有差错的

##### 二维奇偶校验：
- 检测并更正单个位的错误（例子在计算机网络_2_链路层和局域网.ppt中）
- **注意，如果一个2X2的块中四个都出现了差错，那么将无法修改**

#### 循环冗余检验CRC：
- 数据为<font color=#3399FF>k</font>个比特
- <font color=#3399FF>k</font>个比特后面加上<font color=#3399FF>n</font>个比特的供差错检验的冗余码

##### 冗余码的计算：
- 用<font color=#3399FF>k+n</font>个比特的数，使用模2计算的方式，除以事先确定好的除数<font color=#3399FF>P(一个n+1位的数据)</font>
- 每次得到一个余数<font color=#3399FF>R(一个n位的数据，比P少一位)</font>
- 注意<font color=#3399FF>k+n</font>的开头一定是1
- 最后将余数<font color=#3399FF>R</font>作为<font color=#FF0033>冗余码</font>，拼接在数据的后面
- P的选择由多项式决定，规则为：P的最高位和最低位必须为1，也就是说多项式一定有一个次数为P长度的项以及一个常数项，其他次数的项表示：次数对应P的位置上的数字是1
- 详细例子见计算机网络_2_链路层和局域网.ppt

##### 检验：
- 发送端从<font color=#3399FF>n</font>个0开始，CRC后得一个<font color=#3399FF>R</font>，拼接在数据的末尾
- 接收端利用末尾的<font color=#3399FF>n</font>位，CRC后得一个余数<font color=#3399FF>R</font>，<font color=#3399FF>R</font>为0，则接收数据；<font color=#3399FF>R</font>不为0，则丢弃数据

# 广播信道、信道复用

## 链路层不同的“链路”新式
1. 点对点：专享信道，采用PPP协议
2. 广播形式：共享线路或者传输媒介
 - 多接入协议：
  - 原因：广播信道中，往往只有一条共享的信道，然而有两个或多个结点，可能发生同时的数据传输，产生冲突
  - 分布式算法：每个节点上决定是否应该发送信号
  - 何时可以发送信号
  - 注意，所有的协议通信用到的也是该广播信道自身

## 三类多接入协议

### 信道划分

#### TDMA(时分复用)
- 每个节点在每一轮都会获得定长的`时隙slot(源自用户发送的数据)`
- 每个节点在一定的时间产生一个`帧(frame)`，每一个帧存放固定数量的`slot`，`slot`按顺序添加
- 如果在某个时间节点，某个主机没有发送数据，那么它的`slot`位置将空闲
- 即使有用户在持续发送数据，也不可以使用这些空隙，所以造成了很大的浪费

#### STDMA(统计时分复用)
- 使用<font color=#3399FF>集中器</font>，对TDMA进行改进
- 使用STDM帧来传送复用的数据，每个STDM帧的时隙数小于用户的数量
- 动态将数据添加进时隙，当一个帧满了就发送出去

#### FDMA(频分复用)
- 每个用户分配一个固定的频段
- 用户数量越大，所需的带宽就要越大

#### CDMA(码分复用)
- 将需要发送的信号通过不同的编码进行调制，然后复用广播信道

### 随机接入

#### Slotted ALOHA
- 基本假设：
 - 所有帧大小一致
 - 时间轴划分为等长的时隙，通常是传输一帧的时间
 - 节点均只在时隙开始的时候传输
 - 节点的行为是同步的
 - 如果超过两个节点在一个时隙同时传输，则所有节点能侦测到碰撞
- 操作
 - 当一个节点获得一个新的帧，则在下一个时隙开始的时候传输：
  - 如果没有碰撞，则传输成功，该节点成功传输了这个帧
  - 如果发生碰撞，则传输失败。该节点在以后的每一个时隙均以概率𝑝进行重传，直至传输成功
- 优点
 - 每个时隙中，都有一个节点可以一直以全速进行传输
 - 高度分布式算法：只需把所有节点的时隙进行同步即可，其余全部是通过节点自行探测解决
- 缺点
 - 碰撞，且浪费了很多时隙，也会有很多时隙是闲置的
 - 需要一个时隙去侦测碰撞的发生。但事实上节点可能只需要更少的时间就可以侦测碰撞
 - 需要时钟同步
- 效率
 - 设节点数N，每个节点在每个时隙成功发送的概率为p
 - 则“某个节点在某个时隙发送成功”的概率为：<font color=#3399FF>p(1-p)^(N-1)</font>
 - 则“任意结点在某个时隙发送成功”的概率为：<font color=#3399FF>p0=N*p(1-p)^(N-1)</font>
 - 求出，当<font color=#3399FF>p=1/N</font>时，p0有最大值<font color=#3399FF>p0=(1-1/N)^(N-1)</font>
 - 求Slotted ALOHA的最大效率，则对p0求极限（N->∞），极限为<font color=#3399FF>1/e</font>，即36.8%

#### CSMA(Carrier Sense Mutiple Access)协议家族
- 发送数据前先监听广播信道，如果信道空闲，则发送整个帧；如果信道正忙，则延迟发送

##### 碰撞检测
- “碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。
- 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。
- 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。
- 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。
- 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。
- 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。
- 最先发送数据帧的站，在发送数据帧后至多经过时间`2𝜏（两倍的端到端往返时延）`就可知道发送的数据帧是否遭受了碰撞。
- 以太网的端到端往返时延2𝜏称为<font color=#FF0033>争用期</font>，或<font color=#FF0033>碰撞窗口</font>。
- 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。
- 在10M bit/s的以太网中，传统取51.2𝜇𝑠为争用期的长度。对应在争用期内，可以发送512bit（64 byte）的数据
 - 即：若前64字节没有发生冲突，则该帧的后续数据不会发生冲突
 - 一半时间（25.6𝜇𝑠）对应着以太网的最大端到端的长度，约为5km（玻璃纤维中的信号传播速度约为200km/ms）

##### CSMA/CD算法
1. 网卡（NIC）从网络层收到数据报文，包装成帧
2. 如果NIC检测到信道空闲，则开始发送数据；反之，则等待直至信道空闲，然后发送数据
3. 如果网卡成功传输了整个帧，并没有遇到其他同时的传输，则该帧传输完成！
4. 如果NIC在发送帧的过程中检测到发生碰撞，则中止发送，并发送拥塞信号
5. 中止发送后，NIC进入二进制指数退避（binary exponential backoff）：
 - 基本退避时间为争用期2𝜏。
 - 若已经经过m次重传，则从整数集合{0,1,…,2^𝑚−1}中随机取出一个数，定为k。重传所需的时延即为k倍的争用期。
 - 重传16次仍不能成功，则丢弃该帧，并向更高层次的协议报告。
 - Truncated binary exponential backoff：经过m次重传后，整数集合选定为{0,1,…,2^(𝑚^′ )−1}, 𝑚^′=min⁡{𝑚, 10}.

### 受控接入

#### 轮询(polling)
- 主节点(master)邀请次节点(slave)轮流发送数据

#### 令牌传递(token passing)
- 受控的令牌从一个节点依次序传递到下一个节点
- 有令牌的节点即可发送帧

# 链路层寻址

## MAC(Media Access Control)地址
- 48位，通常都烧录进NIC的ROM中，有时候也可以通过软件设定
- 注意：并不是一台电脑或者一台路由器/交换机只有一个MAC地址，MAC地址是和端口绑定的
- 前24位(3字节)——组织唯一标识符
- 后24位(3字节)——扩展唯一标识符

- 适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。
 - 如果是发往本站的帧则收下，然后再进行其他的处理。
 - 否则就将此帧丢弃，不再进行其他的处理。

- “发往本站的帧”包括以下三种帧： 
 - 单播 (unicast) 帧（一对一）
 - 广播 (broadcast) 帧（一对全体）
 - 多播 (multicast) 帧（一对多）

## NIC检查MAC地址
- 所有的适配器都至少能够识别前两种帧，即能够识别单播地址和广播地址。
- 有的适配器可用编程方法识别多播地址。
- 只有目的地址才能使用广播地址和多播地址。
- 以混杂方式 (promiscuous mode) 工作的以太网适配器只要“听到”有帧在以太网上传输就都接收下来。

## ARP(Adress Resolution Protocal)协议
- ARP表：局域网中的每个节点（主机、路由器等）都有一张表，称之为ARP表。
 - 存储了局域网中某些节点的IP地址/MAC地址的映射关系。
 - IP address; MAC address; TTL
 - TTL (time to live): 多久之后忘记该映射（典型值：20分钟）。

## ARP协议——同一局域网内
- A需要发送数据报给B
 - 假设A的ARP表中并没有B的MAC地址
 - 虽然A知道B的IP地址，在网络层A知道B的位置，但是链路层A并不知道
- A发送广播ARP查询packet，包含了B的IP地址
 - 该packet中的目的MAC地址是FF-FF-FF-FF-FF-FF（广播）
 - 局域网中所有节点都收到了该查询
- B收到该packet，将自身的MAC地址回复给A
 - 这个回复帧，发送给A的MAC地址（单播）
- A将学习到的IP-MAC地址映射存放在其ARP表中，直到该信息过时：
 - 除非更新信息，否则在TTL后该信息即为过时
- ARP协议是“即插即用”的：
 - 节点创建自己的ARP表格，并不需要网络管理员的人工干涉

## ARP协议——不在同一局域网内
- 过程基本相同，但需要分开先从边缘路由器跳转，获得各自的MAC地址

# 以太网

## 以太网的帧结构

|preamble|dest.address|source address|type|data|CRC|
|:---:|:---:|:---:|:---:|:---:|:---:|
|8 byte|MAC 6 byte|MAC 6 byte|2 byte|46~1500 byte|4 byte|

### preamble
- 由前7个重复的字节`10101010`和最后一个字节`10101011`组成
- 前7个字节为`前同步码`，用于MAC帧的比特同步
- 第8个字节为`帧界定符`，用于界定MAC帧的开始

### dest.address
- 6个字节的目标MAC地址

### source address
- 6个字节的源MAC地址

### type
- 2个字节的，用于告诉目标MAC收到该帧后，传输到上一层的何种协议

### data
- 数据字段的正式名称是`MAC客户数据字段`
- 最小长度64字节-18字节的首部和尾部=数据字段的最小长度(46字节)

### FCS(Frame Check Sequence)
- 4个字节的，加入了CRC冗余码的序列

### 无效帧
- 帧长度不是整数字节
- CRC校验失败
- data不在范围内
- MAC帧长度不在64~1518字节之间
- 直接丢弃，不再重传

# 交换机
- 在链路层扩展以太网，最常用的方法是使用交换机
- 交换机只有两层：物理层和链路层，因为交换机只负责将收到的帧从一个端口转向另一个端口，而不需要做更多复杂的事情
- 注意：交换机的每个接口都是一个碰撞域
 - 也就是说，不同的接口若是同时发送帧，将不会发生冲突 


## 交换机通过交换表查询可访问的接口
|主机的MAC地址|可以通过哪个接口访问|有效期|
|:---:|:---:|:---:|
||||
|||| 

## 自学习
- 交换机通过自学习实现交换表的更新余维护
- 当交换机收到一个帧时：
 - 记录主机MAC地址以及使用的端口
  - 如果表中有`des.address`的信息，那么将发送数据
  - 如果`des.address`==`source address`，丢弃帧
  - 如果没有，则广播

## 交换机毒化
- 通过发送大量的具有不同伪造源MAC地址的分组，因而用伪造表项填满了交换表，减少了合法主机的空间

# VLAN虚拟局域网
- 使用交换机可以构造VLAN，VLAN不会收到来自其他VLAN的信息
- 每个VLAN都是一个广播域

|方法|描述|缺点|
|:---:|:---:|:---:|
|基于交换机端口的方法|属于在第一层划分VLAN的方法|不便于移动|
|基于计算机网卡的MAC地址方法|属于在第二层划分VLAN|方便移动，但不便于维护|
|基于协议类型的方法|通过链路层帧的`type`来区分，属于第二层||
|基于IP子网地址的方法|根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段来区分，属于第三层||
|基于高层应用或服务的方法|||

## VLAN使用的以太网帧格式
- 802.3ac定义了以太网帧格式的扩展
- 即在`source address`后插入一个4字节的`802.1Q`标记，用来指明该帧来自于哪个局域网



# 网络层向运输层提供“无连接的、尽最大努力的”数据报服务
- 无连接即网络层发送分组时不需要先建立链接
- 同时，网络层不提供质量服务承诺
- 如果主机之间需要建立可靠的链接，那么就交由运输层负责

# 网络层的重要作用
1. 转发：将分组从路由器的输入端口转发到合适的输出端口
2. 路由：决定分组从发送端到接收端的的具体路径

# 数据平面和控制平面
- 数据平面：
 - 本地、基于单个路由器的行为
 - 主要行为：转发

- 控制平面：
 - Network-wide的行为
 - 主要行为：路由
 - 两种控制平面的路由做法：
   - 传统的路由算法：在每个路由器上运行路由算法，决定分组的路由
   - SDN（软件定义网络Software-defined Networking）：在 中心服务器上定义路由算法。

- 也就是说，一个路由叫数据平面，多个路由叫控制平面

## 传统路由方法
- 每一个路由器上都要布置路由算法，这些路由算法组成了控制平面

## SDN的路由
- 和传统路由不同，控制平面不是部署在每个路由器中的，而是逻辑上中心化的。
- 控制平面往往并不需要和数据平面部署在一起。
- 路由器中不再部署算法，只是控制平面的代理/中介。
- 举个例子：一个远程的控制平面，控制若干个没有布置路由算法的路由（数据平面），这些数据平面将根据控制平面来进行转发的行为


# IP协议

## IP地址
- IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符
 - 一般用形如X.X.X.X的方式表示，每个X对应8位的二进制数

### 编址方法
#### 分类IP地址
- 将IP地址划分为若干个固定类
- 每一类地址都由两个固定长度的字段组成：
 - 网络号(net-id)：标志主机（或路由器）所连接的网络
 - 主机号(host-id)：标志该主机（或路由器）
 - 主机号在它前面的网络号范围内必须是唯一的
- IP地址::={(net-id)(host-id)}

|地址类别|net-id长度|host-id长度|补充|
|:---:|:---:|:---:|:---:|
|A类地址|8bit|24bit|最高位必须为0|
|B类地址|16bit|16bit|最高位必须为10|
|C类地址|24bit|8bit|最高位必须为110|
|D类地址|||多播地址，前四位必须为1110|
|E类地址|||保留地址，无实际作用，前四位必须为1111|

- IP地址不可以全0全1，因为没有意义，所以在计算范围大小的时候我们要减去这两种情况
|网络类型|最大可指派的网络数|第一个可指派的网络号|最后一个可指派的网络号|每个网络中最大的主机数|
|:---:|:---:|:---:|:---:|:---:|
|A|126(2^7-2)|1|126|16777214|
|B|16383(2^14-1)|128.1|191.255|65534|
|C|2097151(2^21-1)|192.0.1|223.255.255|254|

- 一般不使用的特殊的ip地址
|网络号|主机号|源地址使用|目的地址使用|代表的意思|
|:---:|:---:|:---:|:---:|:---:|
|0|0|可以|不可|在本网络上的本主机(用于DHCP协议)|
|0|host-id|可以|不可|在本网络上的某台主机|
|全1|全1|不可|可以|旨在本网络上进行广播|
|net-id|全1|不可|可以|对net-id上的所有主机进行广播|
|127|非全0或全1的任何数|可以|可以|用于本地软件环回测试|

- 全0和全1在分类IP编码方法中通常是不计的

#### 子网划分
- 见PPT

#### 无分类编址（CIDR）
- 见PPT

- 对“IP地址是否连续分配给了各系”的思考：
- 首先，答案是连续地分配了
 - 我们先看大学X的地址206.0.68.0/22，二进制表示为11001110.00000000.010001*，这里表示这个大学一共有2^10个地址可以进行分配
 - 我们再看一系的地址206.0.68.0/23，二进制表示为11001110.00000000.0100010*，这里表示一系一共有2^9个地址可以分配
   - 我们再看206.0.68.0/23的地址块，它是从11001110.00000000.01000100.00000000开始，一直到11001110.00000000.01000101.11111111的，先记住这一点
 - 我们再看二系的地址206.0.70.0/24，二进制表示为11001110.00000000.01000110.*，这里表示二系一共有2^8个地址可以分配
   - 我们再看206.0.70.0/24的地址块，它是从11001110.00000000.01000110.00000000开始，一直到11001110.00000000.01000110.11111111的
   - 现在，比较这个范围和一系的范围，发现了
     - 一系：11001110.00000000.01000100.00000000-11001110.00000000.01000101.11111111
     - 二系：11001110.00000000.01000110.00000000-11001110.00000000.01000110.11111111
     - 一系最大地址加1，即二系最小地址
     - 所以是连续分配的

## IP数据报格式+分片与重组
- 一个IP数据报由首部和数据两部分组成
- 首部的前一部分（不包括可选字段和填充部分）是固定长度，共20字节
- 在首部的固定部分后面是可选字段，其长度是可变的
 - 所以首部有一个首部长度的部分，就是因为可选字段的存在

![IP数据报](http://c.biancheng.net/uploads/allimg/191106/6-191106153044K1.gif)

### IP数据报的固定部分
- 这一部分的长度是固定的，共20字节，每一个IP数据报都会有的

#### 版本
- 共4bit，绝大多数都为IPv4

#### 首部长度
- 共4bit，可以表示0-15的数字，即表示5-15个单位：
 - 单位：一个单位为4byte
  - 因为首部的固定部分为20byte，即5个单位，所以首部长度应该从5开始
  - 因为首部长度最大为15个单位，所以首部长度最大为60byte

#### 区分服务
- 共8bit，用来获得更好的服务
- 在旧标准中叫做服务类型
- 只有在使用区分服务时(DiffSery)时，这个字段才起作用，否则一般不起作用

#### 总长度
- 占16bit，包括首部和数据之和的长度
- 因此数据报的最大长度为2^16-1=65535字节
- 总长度不得超过最大传送单元MTU
 - <font color=#FF0000>最大传输单元（Maximum Transmission Unit，MTU）</font>：用来通知对方所能接受数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。

#### 标识
- 占16bit，它是一个计数器，用于产生IP数据报的标识
- IP 协议在存储器中维持一个计数器。每产生一个数据报，计数器就加 1，并将此值赋给标识字段。
- 当数据报的长度超过网络的 MTU，而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。具有相同的标识字段值的分片报文会被重组成原来的数据报。

#### 标志
- 占3bit，目前只有后两位有意义
- 标志字段的最低位是MF(More Fragment)，当该位为1时表示后面还有分片
- 标志字段的中间一位是DF(Don't Fragment)，只有当DF为0时才可以分片
 - 因为链路层帧的数据长度只有46~1500byte，而IP数据报的数据长度最长可达65535-60=65475byte，所以一个很长的IP数据报到了链路层将会被分片
 - 比如：
  - 一个3820byte的数据报，需要分片长度不超过1420byte的分片
  - 那么久将20byte的首部复制3遍，再将3800byte的数据分为1400byte,1400byte,1000byte的3个分片
  - 每个分片再加上20byte的首部，但必须修改有关字段的值

#### 偏移量
- 用于标记分片处于原来的数据报的位置
- 比如上面举的例子
 - 第一个1400byte的分片的偏移量为0/8=0byte
 - 第二个1400byte的分片的偏移量为1400/8=175byte，即表示这部分从原来报文的第175byte开始
 - 第三个1400byte的分片的偏移量为2800/8=350byte，即表示这部分从原来报文的第350byte开始

- IP数据报首部中与分片有关的字段中的值
||总长度|标识|DF|MF|偏移量|
|:---:|:---:|:---:|:---:|:---:|:---:|
|原始数据报|3820|12345|0|0|0|
|分片1|1420|12345|0|1|0|
|分片2|1420|12345|0|1|175|
|分片3|1020|12345|0|0|350|


#### 生存时间
- 占8bit，记为TTL(Time To Live)，指示数据报在网络中可通过的路由器数的最大值

#### 协议
- 占8bit，指出此数据报携带的数据使用何种协议，以便IP层将数据上交给那个协议处理

#### 首部检验和
- 占16bit，只检验数据报的首部，不检验数据部分
- 操作流程：
 1. 将检验和置为全0
 2. 将首部的所有内容以16byte的方式分组，不管它属于哪部分
 3. 将所有分组取反，求和，再取反
   - 若在求和的任一过程中求到的结果多一位（即最高位多一个1），那么将这个1去掉，整个结果再加1（也可以理解为把这个1移到了末尾相加）
   - 比如1110 0110 0110 0110 + 1101 0101 0101 0101 得到的和是 （进位1）后面跟着1011 1011 1011 1011，所以最后的sum是1011 1011 1011 1100，所以checksum是0100 0100 0100 0011
 4. 最后得到一个16bit的检验和

- 检验流程：
 1. 和前面一样，以16byte为分组
 2. 全部取反，相加，再取反
 3. 若最后得到的结果为全0，则保留

#### 源地址，目的地址
- 都为32bit的IP地址

#### 可变部分
- IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富
- 选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。
- 增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。

## NAT(Network Address Translation)
- 当使用NAT的时候，我们所知道的IP地址唯一就显得没有特别的必要了
- 因为ISP可以认为，某一个地址代表了多台主机
 - 举个例子，ISP知道你家的路由器的IP地址，但是不需要知道和路由器相连的设备的IP地址
 - 也就是说，这个路由器代表了所有与之相连的主机

- 使用NAT时，通常有两个特性
 1. 透明性
   - 可以更改本地设备的IP地址而不需要通知外部世界
   - 可以更改ISP而不需要更改本地的IP地址
 2. 安全性
   - 本地网络内的设备不能直接被外部世界的设备访问

### 本地地址、全球地址、专用地址
- 本地地址：
 - 仅在机构内使用的IP地址，不需要向ISP申请
- 全球地址：
 - 全球唯一的IP，很牛逼，稀缺资源，必须申请

- 专用地址(private address)：
 - 为了解决本地地址和全球地址的二义性问题提出的
 - 专用地址只表示本地地址，当路由器接收到一个发往专用地址的数据报，一律不进行转发

 - 三个专用地址的地址块
 1. 10.0.0.0到10.255.255.255
   - A类，又记为10.0.0.0/8，它又称为24位块
 2. 172.16.0.0到172.31.255.255
   - B类，又记为172.16.0.0/12，它又称为20位块
 3. 192.168.0.0到192.168.255.255
   - C类，又记为192.168.0.0/16，它又记为16位块

### NAT的两种实现方式

#### NAT(纯粹的地址转换)
- 举个例子
 - 假设专用网(192.168.0.0)中的主机A(192.168.0.3)向外界的主机B(213.18.2.4)发送数据，中间经过路由(172.38.1.5)
 - 那么数据报一开始的目的地址就为路由的172.38.1.5
 - 路由接受到数据报后，将源地址改为自己的172.38.1.5，并且将路由表更新，记录192.168.0.3->213.18.2.4的信息
 - 主机B接受到数据报，发回反馈，目的地址为路由的172.38.1.5
 - 路由接收到主机B的数据报，根据路由表，将数据报的目的地址改为192.168.0.3，并发回主机A
- 那么问题就在：
 - 若路由连接多台主机，多台主机同时发送数据，那么仅有1个全球IP地址的路由是不够用的，排队使用显然也很不现实
 - 而且若路由表内无信息，那么外界是无法访问专用网内的主机的，也就是说专用网内的主机不可以作为服务器使用


#### NAPT(Network Address and Port Translation)
- 利用地址和端口进行转换
- NAT路由器只需要具有一个全球IP地址就足够了。不通过IP地址来区分不同的本地、源IP地址，而通过NAT路由器上的端口号来区别。
 - 其实就是利用端口表示n个IP地址
- 操作基本是一样的，注意每次发送和接受都要带上端口号



## IPv6
- IPv6仍然支持无连接的传送
- IPv6和IPv4的主要区别是：
1. 更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 
2. 扩展的地址层次结构。 
3. 灵活的首部格式。 IPv6 定义了许多可选的扩展首部。
4. 改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。
5. 允许协议继续扩充。 
6. 支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。
7. 支持资源的预分配。  IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。
8. IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。

### IPv6数据报的一般形式
- IPv6数据报由两大部分组成
1. 基本首部
2. 有效载荷。有效载荷允许由零个或多个扩展首部，再后面是数据部分

#### 基本首部
- 版本（4位）：IPv4总是对应4，IPv6总是对应6
- 通信量类（8位）：为了区分不同的IPv6数据报的类别或优先级
- 流标号（20位）：“流”是互联网络上从特定源点到特定终点的一系列数据报， “流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号。 
- 有效载荷长度（16位）：指明IPv6数据报除了基本首部之外的字节数，最大为64KB
- 下一个首部（8位）：相当于IPv4的协议字段或可选字段
- 跳数限制（8位）：源站在数据报发出时即设定跳数限制。路由器在转发数据报时将跳数限制字段中的值减 1。当跳数限制的值为零时，就要将此数据报丢弃。 
- 源地址
- 目的地址


#### 扩展首部
- IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站的主机来处理。
- 数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。
- 这样就大大提高了路由器的处理效率。 

### IPv6的地址
- IPv6采用冒号16进制记法，支持零压缩，支持CIDR的斜线表示法
#### IPv6的地址分类
|地址类型|二进制前缀|冒号16进制记法|
|:---:|:---:|:---:|
|未指明地址|全0|::/128|
|环回地址|00...1/128|::1/128|
|多播地址|11111111(8位)|FF00::/8|
|本地链路单播地址|1111111010(10位)|FE80::/10|
|全球单播地址|（除上述四种外，所有其他的二进制前缀）||

#### IPv6的目的地址
1. 单播
2. 多播
3. 任播：这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。 

#### 向IPv6过渡的策略
1. 使用双协议栈：一台主机（或路由器）装有两个协议栈，根据 DNS 返回的地址类型可以确定使用 IPv4 地址还是 IPv6 地址
2. 使用隧道技术：当IPv6数据报进入IPv4网络时，先将IPv6数据报封装成IPv4数据报

# 路由协议-基本概念、术语
## 分层次的路由选择协议
### 自治系统(AS)
- 定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。
- 重要的是一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。
### 路由选择协议
- 内部网关协议IGP(Interior Gateway Protocol)
 1. 在一个AS内部使用的路由选择协议
 2. 如RIP和OSPF协议
- 外部网关协议EGP(External Gateway Protocol)
  1. 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。
  2. 在外部网关协议中目前使用最多的是 BGP-4

- 自治系统之间的路由选择也叫做域间路由选择 (inter-domain routing)，在自治系统内部的路由选择叫做域内路由选择 (intra-domain routing) 。

## 两类基本路由算法
### Dijistra算法（略）
### 距离向量算法
- Bellman-Ford等式
  1. 用𝐷_𝑥 (𝑦)表示“从x到y的最佳路径的成本”
  2. 则有𝐷_𝑥 (𝑦)=   min┬𝑣⁡〖{𝑐(𝑥,𝑣)+𝐷_𝑣 (𝑦)}〗
  3. “x到v的成本”+“从v到y的最佳路径的成本”
- 其他见课件计算机网络_4_网络层-控制平面
- 注意，每个路由器的距离向量表发生变化时，都要向相邻的路由器发送这种变化，时间长以后，估计可以收敛到真实值

- 两个特点：
1. “好消息传得快”：
 - 这个很好理解，就是说一个路由器的距离向量变小的时候，将新的距离向量发送给邻居，邻居更新自己的距离向量表，这样在下一次传送报文的时候可以选择距离最短的路径
2. “坏消息传得慢”：
  - 这个需要结合PPT上的图进行理解
  - 总的来说，当某两个路由器之间的距离变大的时候，在发送这种更新的时候，容易产生路由环路（即x->y->z,z->y->x）
  - 并且由于距离向量表是根据其他路由器发送的表来进行维护的，所以这种错误就有可能传遍整个网络
3. 避免路由环路的方法：
- 毒性逆转，比如当z->y->x的时候，z向下一个路由器通告Dz(x)=∞，防止报文重新经过y到达x

### Dijstra算法 VS 距离向量算法
1. 消息的复杂度
  1. Dijstra
     - n个结点，E条链路，则需要O(nE)条消息
  2. 距离向量算法
     - 消息只在相邻结点之间传播，数目不定
2. 收敛速度
  1. Dijstra
     - O(n^2)
  2. 距离向量算法
     - 收敛时间不定，存在路由环路，无穷计数问题
3. 健壮性
  1. Dijstra
     - 节点可能会广播错误的链路成本
     - 每个路由器只维护自己的转发表
  2. 距离向量算法
     - 节点可能会广播错误的路径成本
     - 因为转发表是依靠其他路由器所发的转发表进行维护的，所以错误会在网络中逐渐传播

## 内部网关协议、外部网关协议
### 内部网关协议
#### 路由信息协议RIP(Routing Information Protocol)
- RIP基于距离向量算法
- RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 
##### 距离的定义
- 一个路由器到直接连接的网络的距离为1
- 一个路由器到非直接连接的网络的距离为所经过的路由器数加1
- 每经过一个路由器，距离加1
- RIP允许一条路径最多只能包含15个路由器
- RIP不能在两个网络之间同时使用多条路由。RIP选择一个具有最少路由器的路由，哪怕还存在另一条高速（低时延）但路由器较多的路由
##### RIP的特点
1. 仅和相邻路由器交换信息
2. 交换的信息是当前本路由器所知道的全部信息，即自己的路由表
3. 按固定的时间交换路由信息
##### 路由表的建立
1. 首先，路由器只知道和自己距离为1的路由器，它的路由表是空的
2. 以后，路由器也只跟数目非常有限的相邻路由器交换并更新路由表
3. 最后，每个路由器都会知道在本自治系统中到达任意一个路由器的最短路径
4. RIP协议的“收敛”速度比较快。“收敛”即指在自治系统中所有的节点都得到正确的路由选择信息的过程
##### RIP中的距离向量算法
- 以路由器收到相邻路由器X的RIP报文为例子
1. 先修改此RIP报文中的所有项目：
  - 把“下一跳”字段中全部改为路由器，并把所有“距离”字段的值加1
2. 对修改后的RIP报文中的每一个项目，重复以下步骤：
  - 若项目中没有出现目的网络，则把该目的网络和距离添加到路由表中（注意这里添加的是修改版）
  - 若下一条字段给出的路由器地址是同样的X，则把收到的项目替换原路由表中的项目
  - 若下一条字段中给出的路由器地址不同于X，则比较旧距离和新距离的大小，谁小留谁
3. 若3分钟还没有收到相邻路由器的更新路由表，则把此路由器记为不可达路由器，将距离设置为16
4. 返回
- 这里先要修改报文，是根据距离向量算法的原理，更新的是通过路由器X，到目标网络的距离向量
##### RIP2协议报文的格式
###### 首部
- 共4字节
|命令|版本|必为0|
###### 路由部分
- 由若干个路由信息组成，每个路由信息都需要20字节
- 地址族标识符用来标志所使用的协议
- 路由标记填入自治系统的号码，这是考虑使RIP有可能收到本自治系统以外的路由选择信息
- 一个RIP报文最多可包含25个路由，所以RIP报文的最大长度是4+20*25=504字节
|地址族标识符|路由标记|
|:---:|:---:|
|网络地址|
|子网掩码|
|下一跳路由器地址|
|距离（1-16）|
###### IP数据报
|IP首部|UDP首部|RIP报文|
|:---:|:---:|:---:|
- UDP用户数据报由UDP首部和RIP报文组成
##### RIP2的鉴别功能
1. 若使用鉴别功能，则将放第一个路由信息的位置用作鉴别
2. 在鉴别数据之后才写入路由信息，此时RIP路由表最多放入24个路由器的信息
##### RIP的优缺点
- 优点：实现简单，开销较小
- 缺点：
  1. RIP限制了网络规模，因为它的最大距离为16
  2. 路由器之间交换的是完整的路由表，随着网络规模的扩大，开销也增大
  3. “坏消息传得慢”

#### 开放最短路径优先OSPF(Open Shortest Path First)
- OSPF采用分布式的链路状态协议
##### OSPF三个要点
1. 向本自治系统中所有的路由器发送信息，使用的是洪泛法
2. 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息
  - “链路状态”就是说明本路由器都和那些路由器相邻，以及该链路的“度量”
3. 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息
##### OSPF的区域
- 为了使OSPF应用于大规模网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域
- 每一个区域都有一个32位的区域标识符（点分十进制表示）
- 一个区域的路由器最好不超过200个
- 上层的区域叫做主干区域，标识符位0.0.0.0，用来连通其他在下层的区域
- 主干区域中的路由器分为：
  1. 主干路由器
  2. 区域边界路由器：即和下层区域连通的路由器
- 优点：
  1. 洪泛时，只需要在区域内部进行而不需要整个网络进行
  2. 路由器只知道本区域内的网络拓扑，而不知道整个网络的

### 外部网关协议
#### 边界网关协议BGP(Border Gateway Protocol)
