# 

# 分组密码
## DES
### DES基本原则：
- 	DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。混淆是使密文的统计特性与密钥的取值之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。
- key：8个字节共64位工作密钥
- data：8个字节共64位数据

### 算法：
#### 密钥组的获取：
- 获取一个64位的密钥
- 将密钥分为8组8位，每组去掉最后一位，得8组7位
- 做PC-1置换
1. PC-1
2. 57 49 41 33 25 17 9
3. 1 58 50 42 34 26 18
4. 10 2 59 51 43 35 27
5. 19 11 3 60 52 44 36
6. 63 55 47 39 31 23 15
7. 7 62 54 46 38 30 22
8. 14 6 61 53 45 37 29
9. 14 6 61 53 45 37 29
10. 21 13 5 28 20 12 4
- 分为C、D两组，密钥被分为2*28组合
- 做16次左移操作得到16轮的C、D组合
                                Iteration     Number of
	                     Number      Left Shifts 
	1.                           1          1
	2.                           2          1
	3.                           3          2
	4.                           4          2
	5.                           5          2
	6.                           6          2
	7.                           7          2
	8.                           8          2
	9.                           9          1
	10.                          10          2
	11.                          11          2
	12.                          12          2
	13.                          13          2
	14.                          14          2
	15.                          15          2
	16.                          16          1
- 对每一对C、D重新组合后，进行PC-2置换，只使用前48位，得到16轮子密钥
                            PC-2
1.  
2.                  14    17   11    24     1    5
3.                   3    28   15     6    21   10
4.                  23    19   12     4    26    8
5.                  16     7   27    20    13    2
6.                  41    52   31    37    47   55
7.                  30    40   51    45    33   48
8.                  44    49   39    56    34   53
9.                  46    42   50    36    29   32

#### 明文的加密：
- 根据IP置换，将明文进行替换
	1.                          IP
	2.  
	3.             58    50   42    34    26   18    10    2
	4.             60    52   44    36    28   20    12    4
	5.             62    54   46    38    30   22    14    6
	6.             64    56   48    40    32   24    16    8
	7.             57    49   41    33    25   17     9    1
	8.             59    51   43    35    27   19    11    3
	9.             61    53   45    37    29   21    13    5
	10.             63    55   47    39    31   23    15    7
- 将变换后的明文M分为左右两块L0、R0（变成2*32的组合）
- 使用函数f：将一个32位的数据块和一个48位的密钥区块，输出成一个32位的区块
- 递归方法：L_n=R_(n−1)；R_n= L_(n−1)+ f(R_(n−1),K_n )
- 为了计算f，首先拓展每个R_(n-1)   ，通过E表将其从32位拓展到48位
1.            E BIT-SELECTION TABLE
2.  
3.                  32     1    2     3     4    5
4.                   4     5    6     7     8    9
5.                   8     9   10    11    12   13
6.                  12    13   14    15    16   17
7.                  16    17   18    19    20   21
8.                  20    21   22    23    24   25
9.                  24    25   26    27    28   29
10.                  28    29   30    31    32    1

- 对E(R_(n−1) )  和K_n 进行异或运算，得48位数据
- 将48位的数据分为6*8，对每组进行S盒替换，得到4*8的数据组合
- S盒替换：
 1. 取6位中的第一位和最后一位组成一个二进制数，转为十进制数，记为I
 2. 取中间4位二进制数，转为十进制数，记为j
 3. 在S盒中查找（I,j），用（i，j）的数字代替原来的6位数据
 4. 每组分别用对应的S盒进行替换：
  - S1(B1)S2(B2)S3(B3)S4(B4)S5(B5)S6(B6)S7(B7)S8(B8) 

- 得到新的4*8的32位数据，做P盒替换
1.                               P
2.  
3.                          16   7  20  21
4.                          29  12  28  17
5.                           1  15  23  26
6.                           5  18  31  10
7.                           2   8  24  14
8.                          32  27   3   9
9.                          19  13  30   6
10.                          22  11   4  25
- 则计算完f，下一步计算R_N=L_(n-1)+f(R_(n-1),K_n )  ，做异或运算
- 经过16轮迭代后，进行最终替换IP-1
	1.                          IP-1
	2.  
	3.             40     8   48    16    56   24    64   32
	4.             39     7   47    15    55   23    63   31
	5.             38     6   46    14    54   22    62   30
	6.             37     5   45    13    53   21    61   29
	7.             36     4   44    12    52   20    60   28
	8.             35     3   43    11    51   19    59   27
	9.             34     2   42    10    50   18    58   26
	10.             33     1   41     9    49   17    57   25
- 最后将密文转换为16进制

## IDEA
### 1.IDEA简介：
- IDEA是International Data Encryption Algorithm 的缩写,是1990年由瑞士联邦技术学院来学嘉X.J.Lai 和Massey提出的建议标准算法称作PES( Proposed Encryption Standard) 。Lai 和Massey 在1992 年进行了改进强化了抗差分分析的能力改称为IDEA 它也是对64bit大小的数据块加密的分组加密算法密钥长度为128位它基于"相异代数群上的混合运算"设计思想算法用硬件和软件实现都很容易且比DES在实现上快的多。IDEA自问世以来，已经经历了大量的详细审查，对密码分析具有很强的抵抗能力，在多种商业产品中被使用。

### 2.算法详解：
#### 2.1 产生密钥
- 算法用了52个子密钥(8轮中的每一轮需要6个，其他4个用与输出变换)。首先，将128-位密钥分成8个16-位子密钥。这些是算法的第一批8个子密钥（第一轮六个，第二轮的头两个）。然后，密钥向左环移x位后再分成8个子密钥。开始4个用在第二轮，后面4个用在第三轮。密钥再次向左环移25位产生另外8个子密钥，如此进行直到算法结束。具体是：

- IDEA总共进行8轮迭代操作，每轮需要6个子密钥,另外还需要4个额外子密钥,所以总共需要52个子密钥，这个52个子密钥都是从128位密钥中扩展出来的。

- 首先把输入的Key分成8个16位的子密钥， 1-6号子密钥供第一轮加密使用，7-8号子密钥供第二轮使用,然后把这个128位密钥循环左移25位，这样Key = k26k27k28.k24k25。

- 把新生成的Key在分成8个16位的子密钥，1-4号子密钥供第二轮加密使用(前面已经提供了两个)5-8号子密钥供第三轮加密使用。到此我们已经得到了16个子密钥，如此继续,当循环左移了5次之后已经生成了48个子密钥,还有四个额外的子密钥需要生成，再次把Key循环左移25位,选取划分出来的8个16位子密钥的前4个作为那4个额外的加密密钥.供加密使用的52个子密钥生成完毕。

- 输入的64-位数据分组被分成4个16-位子分组：xl，X2，x3和x4。这4个子分组成为算法的第一轮的输入，总共有8轮。在每一轮中，这4个子分组相互相异或，相加，相乘，且与6个16-位子密钥相异或，相加，相乘。在轮与轮间，第二和第三个子分组交换。最后在输出变换中4个子分组与4个子密钥进行运算。

#### 2.2 加解密过程：
- 在每一轮中，执行的顺序如下：
1. x1和第一个子密钥相乘。
2. x2和第二个子密钥相加。
3. x3和第三个子密钥相加。
4. x4和第四个子密钥相乘。
5. 将第1步和第3步的结果相异或。
6. 将第2步和第4步的结果相异或。
7. 将第5步的结果与第五个子密钥相乘。
8. 将第6步和第7步的结果相加。
9. 将第8步的结果与第六个子密钥相乘。
10. 将第7步和第9步的结果相加。
11. 将第1步和第9步的结果相加。
12. 将第3步和第9步的结果相异或
13. 将第2步和第10步的结果相异或
14. 将第4步和第10步的结果相异或
- 每一轮的输出是第11、12、13、14步的结果形成的4个子分组。将中间两个分组做分组交换（最后一轮除外）后，即为下一轮的输入
- 经过8轮运算之后，有一个最终的输出变换：
1. x1和第一个子密钥相乘。
2. x2和第二个子密钥相加。
3. x3和第三个子密钥相加。
4. x4和第四个子密钥相乘。
- 最后，这4个子分组重新连接到一起产生密文。


## AES
### AES
- AES为分组密码，AES有不同的分组规范，这里讨论128bit

|AES|密钥长度(32位比特字)|分组长度(32位比特字)|加密轮数|
|:---:|:---:|:---:|:---:|
|AES-128|4|4|10|
|AES-192|6|4|12|
|AES-256|8|4|14|

- AES的大概步骤如下，分为两个大块：
  - 明文加密 
  - 轮密钥产生
- AES算法的基本是分组思想。AES中，基本结构以4*4的矩阵为主，以每一列为一个分组，称为W，明文记为P，密钥记为K
![AES基本结构](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MTMyNTQ4OTA2?x-oss-process=image/format,png "AES基本结构")
-----------------------------
#### 密钥扩展
- 首先我们来讨论密钥扩展
- 以AES的基本结构为基础，将128bit的Key化为矩阵形式
![AES密钥扩展](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjIwMDgyMzE2NzM2?x-oss-process=image/format,png "AES密钥扩展")
- 以图片为例，每四个K组成一个W，每四个W组成一轮密钥
- 现讨论W[i]
 - 如果`i%4 != 0`，那么W[i]由以下等式确定
  - W[i]=W[i-4]xorW[i-1]
 - 如果i是4的倍数，那么W[i]由以下等式确定
  - W[i]=W[i-4]xorT(W[i-1]) 
    - T()是轮函数，包括以下三个过程：
      - a.字循环移位：将一个字4byte向左循环移1位
      - b.字节代换：对字循环的结果做S盒替换
      - c.轮常量异或：将前两步的结果盒Rcon[j]进行异或，其中j表示轮数
  |j|1|2|3|4|5|
  |:---:|:---:|:---:|:---:|:---:|:---:|
  |Rcon[j]|01 00 00 00|02 00 00 00 |04 00 00 00|08 00 00 00 |10 00 00 00|
  |j|6|7|8|9|10|
  |Rcon[j]|20 00 00 00|40 00 00 00|80 00 00 00|1B 00 00 00|36 00 00 00|

 - S盒：
 <table><thead><tr><th>行/列</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0x63</td><td>0x7c</td><td>0x77</td><td>0x7b</td><td>0xf2</td><td>0x6b</td><td>0x6f</td><td>0xc5</td><td>0x30</td><td>0x01</td><td>0x67</td><td>0x2b</td><td>0xfe</td><td>0xd7</td><td>0xab</td><td>0x76</td></tr><tr><td>1</td><td>0xca</td><td>0x82</td><td>0xc9</td><td>0x7d</td><td>0xfa</td><td>0x59</td><td>0x47</td><td>0xf0</td><td>0xad</td><td>0xd4</td><td>0xa2</td><td>0xaf</td><td>0x9c</td><td>0xa4</td><td>0x72</td><td>0xc0</td></tr><tr><td>2</td><td>0xb7</td><td>0xfd</td><td>0x93</td><td>0x26</td><td>0x36</td><td>0x3f</td><td>0xf7</td><td>0xcc</td><td>0x34</td><td>0xa5</td><td>0xe5</td><td>0xf1</td><td>0x71</td><td>0xd8</td><td>0x31</td><td>0x15</td></tr><tr><td>3</td><td>0x04</td><td>0xc7</td><td>0x23</td><td>0xc3</td><td>0x18</td><td>0x96</td><td>0x05</td><td>0x9a</td><td>0x07</td><td>0x12</td><td>0x80</td><td>0xe2</td><td>0xeb</td><td>0x27</td><td>0xb2</td><td>0x75</td></tr><tr><td>4</td><td>0x09</td><td>0x83</td><td>0x2c</td><td>0x1a</td><td>0x1b</td><td>0x6e</td><td>0x5a</td><td>0xa0</td><td>0x52</td><td>0x3b</td><td>0xd6</td><td>0xb3</td><td>0x29</td><td>0xe3</td><td>0x2f</td><td>0x84</td></tr><tr><td>5</td><td>0x53</td><td>0xd1</td><td>0x00</td><td>0xed</td><td>0x20</td><td>0xfc</td><td>0xb1</td><td>0x5b</td><td>0x6a</td><td>0xcb</td><td>0xbe</td><td>0x39</td><td>0x4a</td><td>0x4c</td><td>0x58</td><td>0xcf</td></tr><tr><td>6</td><td>0xd0</td><td>0xef</td><td>0xaa</td><td>0xfb</td><td>0x43</td><td>0x4d</td><td>0x33</td><td>0x85</td><td>0x45</td><td>0xf9</td><td>0x02</td><td>0x7f</td><td>0x50</td><td>0x3c</td><td>0x9f</td><td>0xa8</td></tr><tr><td>7</td><td>0x51</td><td>0xa3</td><td>0x40</td><td>0x8f</td><td>0x92</td><td>0x9d</td><td>0x38</td><td>0xf5</td><td>0xbc</td><td>0xb6</td><td>0xda</td><td>0x21</td><td>0x10</td><td>0xff</td><td>0xf3</td><td>0xd2</td></tr><tr><td>8</td><td>0xcd</td><td>0x0c</td><td>0x13</td><td>0xec</td><td>0x5f</td><td>0x97</td><td>0x44</td><td>0x17</td><td>0xc4</td><td>0xa7</td><td>0x7e</td><td>0x3d</td><td>0x64</td><td>0x5d</td><td>0x19</td><td>0x73</td></tr><tr><td>9</td><td>0x60</td><td>0x81</td><td>0x4f</td><td>0xdc</td><td>0x22</td><td>0x2a</td><td>0x90</td><td>0x88</td><td>0x46</td><td>0xee</td><td>0xb8</td><td>0x14</td><td>0xde</td><td>0x5e</td><td>0x0b</td><td>0xdb</td></tr><tr><td>A</td><td>0xe0</td><td>0x32</td><td>0x3a</td><td>0x0a</td><td>0x49</td><td>0x06</td><td>0x24</td><td>0x5c</td><td>0xc2</td><td>0xd3</td><td>0xac</td><td>0x62</td><td>0x91</td><td>0x95</td><td>0xe4</td><td>0x79</td></tr><tr><td>B</td><td>0xe7</td><td>0xc8</td><td>0x37</td><td>0x6d</td><td>0x8d</td><td>0xd5</td><td>0x4e</td><td>0xa9</td><td>0x6c</td><td>0x56</td><td>0xf4</td><td>0xea</td><td>0x65</td><td>0x7a</td><td>0xae</td><td>0x08</td></tr><tr><td>C</td><td>0xba</td><td>0x78</td><td>0x25</td><td>0x2e</td><td>0x1c</td><td>0xa6</td><td>0xb4</td><td>0xc6</td><td>0xe8</td><td>0xdd</td><td>0x74</td><td>0x1f</td><td>0x4b</td><td>0xbd</td><td>0x8b</td><td>0x8a</td></tr><tr><td>D</td><td>0x70</td><td>0x3e</td><td>0xb5</td><td>0x66</td><td>0x48</td><td>0x03</td><td>0xf6</td><td>0x0e</td><td>0x61</td><td>0x35</td><td>0x57</td><td>0xb9</td><td>0x86</td><td>0xc1</td><td>0x1d</td><td>0x9e</td></tr><tr><td>E</td><td>0xe1</td><td>0xf8</td><td>0x98</td><td>0x11</td><td>0x69</td><td>0xd9</td><td>0x8e</td><td>0x94</td><td>0x9b</td><td>0x1e</td><td>0x87</td><td>0xe9</td><td>0xce</td><td>0x55</td><td>0x28</td><td>0xdf</td></tr><tr><td>F</td><td>0x8c</td><td>0xa1</td><td>0x89</td><td>0x0d</td><td>0xbf</td><td>0xe6</td><td>0x42</td><td>0x68</td><td>0x41</td><td>0x99</td><td>0x2d</td><td>0x0f</td><td>0xb0</td><td>0x54</td><td>0xbb</td><td>0x16</td></tr></tbody></table>
 
 - 下面举个例子：
 - 设初始的128位密钥为：
   - 3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD
 - 分为四组：
   - W[0]=3C A1 0B 21 
   - W[1]=57 F0 19 16
   - W[2]=90 2E 13 80
   - W[3]=AC C1 07 BD
 - 第一步，做字循环移位：
   - W[0]=A1 0B 21 3C
   - W[1]=F0 19 16 57
   - W[2]=2E 13 80 90
   - W[3]=C1 07 BD AC
 - 先计算W[4]，4是4的倍数，因此W[4]=w[0]xorT(W[3])
 - 第二步，对W[3]做字节代换：
   - 比如：替换C1，在S盒中找到第C行，第1列
   - S盒第C行，第1列的值为0x78
   - 把C1替换为78
   - 最后的结果为：W[3]=78 C5 7A 91
 - 第三步，对W[3]和Rcon[1]进行xor运算
   - 得到79 C5 7A 91
 - 因此，得到T(W[3])=79 C5 7A 91
 - 最后，再将得到的`T(W[3])=79 C5 7A 91`和W[0]进行xor运算，得到
   - W[4]=45 64 71 B0
 -其余的3个子密钥段的计算如下：
   - W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6
   - W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26
   - W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B
 - 所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B

- 现在，我们得到了一个44列的轮密钥，一共11组，记为W[i]

#### 明文加密

##### 初始工作
- 首先将明文128bit/16byte同样化为一个4*4的矩阵
|P0|P4|P8|P12|
|:---:|:---:|:---:|:---:|
|P1|P5|P9|P13|
|P2|P6|P10|P14|
|P3|P7|P11|P15|

- 和密钥的扩展一样，做S盒替换

![S盒替换](https://img-blog.csdnimg.cn/20181213112210707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MjA1MTUz,size_16,color_FFFFFF,t_70)


##### 行移位
- 明文加密中的行移位
![行移位](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MTc0MDE1MTY3?x-oss-process=image/format,png)
- 这里的行移位，是在矩阵中，对每一行的操作，和密钥扩展中的字循环移位不同。密钥扩展中的字循环移位是针对每一个W，对字节进行左移一位的操作

##### 列混淆

- 所谓的列混淆是通过矩阵相乘来实现的

![列混淆的矩阵相乘](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MjAzMzQ2NDM2?x-oss-process=image/format,png)

- 运算的过程为：

![矩阵相乘](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MjAzNzQyNTE2?x-oss-process=image/format,png)

- 其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：

![二进制乘法](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MjA0ODIyNTE3?x-oss-process=image/format,png)

- 也就是说，如果a7为1，则进行异或运算，否则不进行。
- 类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MjA1NjAxNjgz?x-oss-process=image/format,png)

- 乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MjEwNTU0MTMz?x-oss-process=image/format,png)

##### 轮密钥相加

- 现在，将操作好的矩阵和对应轮次的密钥做xor运算

![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjIwMDgwNTEyMDg2?x-oss-process=image/format,png)

- 然后我们将得到的结果丢到下一轮中去

### 总体操作

- 现在通过一张图来总结一下AES算法

![AES](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE5MTYxMjAyNDg1?x-oss-process=image/format,png)


### AES解密

（参考https://blog.csdn.net/qq_28205153/article/details/55798628）

## 分组密码的操作模式
### 电子密码本模式(EBC)
- 对每一个明文分组M1,M2,M3...，都使用相同的密钥K来加密
- 优点：支持并行加密和解密。
- 缺点：相同明文分组产生相同密文分组，会暴露明文的统计特性。

### 密码分组链接模式(CBC)
- 每一个密文分组Ci在用密钥K加密之前，都要先跟下一个明文分组Mi+1相异或
![CBC](https://cdn.jsdelivr.net/gh/JNchengge/image@master/CBC.PNG)
- 加密
```
Ci=Enck(Mi xor Ci-1)
```
- 解密
```
Mi=Deck(Ci) xor Ci-1
```
- 优点：相同明文对应不同密文，不会暴露明文的统计特性；支持并行解密。
- 缺点：不支持并行加密

### 密码反馈模式(CFB)
- CFB模式中产生一个密钥流，然后将其与明文相异或。
- 该密钥流从C0=IV开始，然后每次通过加密以前的密文分组来产生密钥流。
![CFB](https://cdn.jsdelivr.net/gh/JNchengge/image@master/CFB.PNG)
- 加密
```
ki=Enck(Ci-1)
Ci=Mi xor ki
即Ci=Mi xor Enck(Ci-1)
```
- 解密
```
Mi=Enck(Ci-1) xor Ci
```
- 优点：相同明文对应不同密文
- 缺点：不能并行计算，传输错误导致后续出错

### 既可以并行加密又可以使得相同明文对应不同密文的算法
1. 实现不依赖明文或密文而生成轮密钥的加密算法，这样生成不同的密钥，使得加密的时候一样可以并行操作，改进了ECB模式的缺点

# 非对称密码
## RSA
1. 选取一对互素的素数p,q
2. 计算pq的乘积n
3. 计算n的欧拉函数,`φ(n)=(p-1)(q-1)`
4. 选取e，使得(e,n)=1，(e,n)作为公钥对
5. 计算私钥d，使得ed=1(mod φ(n))，(d,n)作为私钥对

### 加密
- 使用公钥e进行加密
```
m^e≡c(mod n)
```

### 解密
- 使用私钥d进行解密
```
c^d≡m(mod n)
```