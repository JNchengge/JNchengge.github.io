1. 位置实参：按位置传递实参
2. 关键字实参：按关键字的值传递实参
3. 默认值：在编写函数时，赋给形参一个值
4. 传递任意数量的实参：使用*符号，让python创建一个元组，并将所有收到的值放进元组中,<font color=#AA0000>使用**符号，则是创建一个空字典</font>

5. 导入模块：`import+文件名`，导入模块后，使用“方法”的方式使用函数（文件名.函数名）
6.  `from+文件名+import+函数名[1],函数名[2],+……`，可以直接使用这些函数
7. `from+文件名+import+函数名[1]+as+别名`，也可以为模块起别名`import+文件名+as+别名`
8. `from+文件名+import+*`，导入全部函数

# 汉诺塔问题
## 实现一个普通的汉诺塔
- 汉诺塔问题可以分解为三个子问题：
 1. 把前n-1个圆盘从a移动到b上(a-->b)
 2. 把第n个圆盘从a移动到c上(a-->c)
 3. 把前n-1个圆盘从b移动到a上(b-->c)
- 使用递归可以很直接地表现：
```python
def Hanoi(a,b,c,n):
    if n==1:
        print(a+"->"+c)
    else:
        Hanoi(a,c,b,n-1)  #把前n-1个圆盘从a移动到b上(a-->b)
        Hanoi(a,b,c,1)    #把第n个圆盘从a移动到c上(a-->c)
        Hanoi(b,a,c,n-1)  #把前n-1个圆盘从b移动到a上(b-->c)
a,b,c='A','B','C'
Hanoi(a,b,c,3)
```

```
A->C
A->B
C->B
A->C
B->A
B->C
A->C
```

## 进阶
- 提供一个表示圆盘放置状态的字符串，利用这个字符串解决Hanoi问题
- 例子：`next_state_list("111")结果为：["113","123"]`
 - "111"表示：ABC三个圆盘都在1号柱子上
 - "113"表示：第二和第三个圆盘在1号柱子上，第一个圆盘在3号柱子上
- 和普通版的问题不同，这个问题涉及到了具体的圆盘的位置移动
- 而且，圆盘的表示顺序是倒过来的
- 思路：
 1. 首先确定只有一个盘的时候，要怎么操作：
  - 只有一个盘的时候，也就是考虑最后一个盘的情况，毫无疑问，一定是从a移到c，那我们就找到a的位置（不用担心找错，因为这个时候只有一个a），将它改为c
  - 为什么这里说a,b,c呢，实际上因为情况的不同，a,b,c的角色也会发生变化
  - 比如在做前n-1个圆盘从a移到b时：1号为a，2号为c，3号为b
  - 还需要注意的是，在做这一步之前，我们要先把列表倒序，转为我们普通情况的思路
  - 当然是需要还原的，在移动之后把顺序倒回来，递归的时候就可以实现复原了
 2. 那么接下来，我们递归实现就没问题了，这里可以多设置一个参数l；因为我们操作的是列表，那列表长度始终不变，设置一个l来隐式地表示列表的长度是在变化的
  - 代码如下：
```python
def next_state_list(state,a,b,c,l):
    if l==1:
        state=state[::-1]
        state[state.index(a)]=c
        state=state[::-1]
        print(state)
        return state
    else:
        state=next_state_list(state,a,c,b,l-1)
        state=next_state_list(state,a,b,c,1)
        state=next_state_list(state,b,a,c,l-1)
        return state  #这一步非常关键，如果不返回，那么再回到l=2的时候，就没有state返回了，state变成了Noneobject
a,b,c='1','2','3'
next_state_list(['1','1','1'],a,b,c,3)
```

```
['1', '1', '3']
['1', '2', '3']
['1', '2', '2']
['3', '2', '2']
['3', '2', '1']
['3', '3', '1']
['3', '3', '3']
```

- 思考题：完成next_state_list函数
- 举例：next_state_list("111")结果为：["112","113"]

- 思维方式：按位思考
 - 盘子分为三种，短盘、中盘、长盘，轮流考虑三个柱子：
     - 短盘是否可以移到柱子上
         - 取决于：
             1. 现在考虑的柱子是不是短盘当前位置
                 - 如果是，则不移动
                 - 如果不是，则移动到这个柱子
     - 中盘是否可以移到柱子上
         - 取决于：
             1. 现在考虑的柱子是不是中盘当前位置
             2. 短盘是否在中盘上面
             3. 现在考虑的柱子是不是短盘当前位置，因为如果是的话，中盘也不可以移到这根柱子上
                 - 同时满足这三个条件，则不移动
                 - 反之，移动到这个柱子
     - 长盘是否可以移到柱子上
         - 取决于：
             1. 现在考虑的柱子是否长盘当前位置
             2. 中盘和短盘是否在长盘当前位置 
             3. 中盘和短盘是否在现在考虑的柱子上
                 - 同时满足这三个条件，则不移动
                 - 否则，移动到该位置

```python
def next_state_list(state):
    loc_li = ['1','2','3']
    result_li = []
    short_loc = state[2]
    middle_loc = state[1]
    long_loc = state[0]    
    for loc in loc_li:
        # 不计入不移动的情况
        if loc != short_loc:             
            result_li.append(long_loc+middle_loc+loc)  
        # 不计入不移动的情况、不计入移动不了的情况、不计入放置不上的情况
        if loc != middle_loc and short_loc!=middle_loc and loc != short_loc:
            result_li.append(long_loc+loc+short_loc)
        # 不计入不移动的情况、不计入移动不了的情况、不计入放置不上的情况
        if loc != long_loc and (short_loc!=long_loc and middle_loc!=long_loc) and (loc != short_loc and loc != middle_loc):
            result_li.append(loc+middle_loc+short_loc)
    return result_li

print(next_state_list("321"))
print(next_state_list('111'))
```
```
['322', '323', '331']
['112', '113']

```