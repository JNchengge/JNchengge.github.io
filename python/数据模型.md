- 有些对象包含对外部对象的引用，例如打开文件或者窗口
 - 这些对象最好显式地关闭，比如使用close函数

- 有些对象包含对其他对象的引用，这些对象称为<font colo#3399FF>容器</font>，比如元组、字典、列表，这些引用是组成容器对象值的一部分
 - 当讨论容器的值的时候，指的是所包含的所有引用的值
 - 当讨论容器的可变性时，则仅指其直接包含的对象的编号
  - 因此，如果一个不可变容器对象（比如元组），内含一个可变对象的引用（比如列表），那么在修改列表的值的时候，元组的值也会发生变化
  - 但是，即使是元组的”值“发生了改变，元组还是不可变对象，因为元组的值实际上是对象的引用，也就是一些id，这些id没有发生改变，所以元组没有变
  - 若id指向的是可变对象，是可以改变该对象的值的

- 对于不可变类型，得出新值的运算实际上会返回对相同类型的已存在的对象的引用
 - 比如：
 ```python
 a=1
 b=1
 ```
 就是a指向1，b指向1
- 对于可变类型，绝对不会出现这种i情况
 - 比如：
 ```python
 a=[]
 b=[]
 ```
 就是创建了两个不同的列表对象
 但是：
 ```python
 a=b=[]
 ```
 就是a和b指向同一个列表

## numbers.Integral
- 此类对象包括数学中整数集合的成员
 - 整型(int)：
  - 表示一个任意大小的整数，在变换和掩码的时候使用二进制，复数会以2的补码表示
  - 2的补码：先全部取反，再加1

 - 布尔型(bool)
  - 此类对象表示逻辑值True和False

## numbers.Real(float)
 - 此类对象表示双精度浮点数

## numbers.Complex(complex)
- 此类对象以一对双精度浮点数来表示复数值
- 使用z.real和z.imag来获取实部和虚部
```python
a=complex(1,2)
print(a.real)
print(a.imag)
```

## 序列

### 不可变序列
- 一旦创建就不能再改变
 - 字符串(str)
 - 元组(tuple)
 - 字节串(bytes)

### 可变序列
- 创建后仍可被改变
 - 列表(list)
 - 字节数组(bytearray)

## 集合类型
- 此类对象表示由不重复且不可变对象组成的无序且有限的集合
- 不可通过下标访问
- 可以迭代，属于迭代器
- 常用于去重
- 可以进行交、并、差、对称差的运算

### 可变的集合
- 通过`set()`创建的集合，创建之后可以通过方法修改
- 比如
```python
a=set([1,1,2,3,45,4,64,6])
c=set("asgf")
b=a.difference(c)  #求差集
print(b)
a.add(10)          #添加值
print(a)
b.clear()          #清空集合
print(b)
print(a.copy() is a)    #复制
a.discard(1)        #丢弃元素
print(a)
b=set([1,2,3])
c=a.intersection(b)   #求交集
print(c)
```

```
{64, 1, 2, 3, 4, 6, 45}
{64, 1, 2, 3, 4, 6, 10, 45}
set()
False
{64, 2, 3, 4, 6, 10, 45}
{2, 3}
```
### 不可变集合
- 通过`fronzenset()`创建的集合
- 没有`add`、`discard`、`clear`等方法
```python
a=frozenset([1,1,2,3,45,4,64,6])
c=set("asgf")
b=a.difference(c)  #求差集
print(b)
print(a.copy() is a)    #复制
b=set([1,2,3])
c=a.intersection(b)   #求交集
print(c)
```
```
frozenset({64, 1, 2, 3, 4, 6, 45})
True
frozenset({1, 2, 3})
```
- 在复制的时候，体现了不可变对象的特性，即指向一个现存的不可变对象

- 由于不可变对象不可变且hashable，因此可以作为另一个集合的值或者字典的值
```python
import pprint
a=frozenset([1,1,2,3,45,4,64,6])
b=set([a,1,2,3,"asf"])
print(b)
d={'1':a,'2':'002'}
pprint.pprint(d)
```

```
{1, 2, 3, 'asf', frozenset({64, 1, 2, 3, 4, 6, 45})}
{'1': frozenset({64, 1, 2, 3, 4, 6, 45}), '2': '002'}
```

## 字典
- 字典会保留插入顺序，这意味着键将以它们被添加的顺序在字典中依次产生。 替换某个现有的键不会改变其顺序，但是移除某个键再重新插入则会将其添加到末尾而不会保留其原有位置

## 可调用类型
### 用户自定函数
#### 特殊属性
|属性|含义||
|:---:|:---:|:---:|
|__doc__|该函数的文档字符串，没有则为None|可写|
|__name__|该函数的名称|可写|
|__qualname__|该函数的qualified name|可写|
|__module__|该函数所属模块的名称|可写|
|__defaults__|由具有默认值的参数默认参数值组城的元组，无默认值则为None|可写|
|__code__|表示编译后的函数体的代码对象|可写|
|__globals__|对存放该函数中全局变量的字典的引用|只读|
|__dict__|命名空间支持的函数属性|可写|
|__closure__|None 或包含该函数可用变量的绑定的单元的元组|只读|
|__annotations__|包含参数标注的字典。字典的键是参数名，如存在返回标注则为 'return'|可写|
|__kwdefaults__|仅包含关键字参数默认值的字典|可写|

- __qualname__
 - 一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类
 ```python
class C:
    class D:
        def foo(self):
            pass
print(C.__qualname__)
print(C.D.__qualname__)
print(C.D.foo.__qualname__)
print(C.D.foo.__name__)
print(C.D.__name__)
print(C.__name__)
 ```

 ```
C
C.D
C.D.foo
foo
D
C
 ```

 - 和`__name__`的区别在于，`__name__`表示的是当前所在定义的名字

